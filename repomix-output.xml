This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.bolt/config.json
.bolt/prompt
.gitignore
eslint.config.js
index.html
package.json
postcss.config.js
public/mockServiceWorker.js
src/api/tournaments.ts
src/App.tsx
src/components/BracketGrid.tsx
src/components/Button.tsx
src/components/ExportOptions.tsx
src/components/Footer.tsx
src/components/Input.tsx
src/components/Layout.tsx
src/components/MatchCard.tsx
src/components/Navbar.tsx
src/components/Select.tsx
src/components/TournamentCard.tsx
src/components/TournamentForm.tsx
src/index.css
src/main.tsx
src/mocks/browser.ts
src/mocks/data.json
src/mocks/handlers.ts
src/pages/AboutPage.tsx
src/pages/BracketPage.tsx
src/pages/DashboardPage.tsx
src/pages/NotFoundPage.tsx
src/pages/TournamentEditPage.tsx
src/pages/TournamentFormPage.tsx
src/pages/TournamentSettingsPage.tsx
src/types/tournament.ts
src/utils/dateUtils.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".bolt/config.json">
{
  "template": "bolt-vite-react-ts"
}
</file>

<file path=".bolt/prompt">
For all designs I ask you to make, have them be beautiful, not cookie cutter. Make webpages that are fully featured and worthy for production.

By default, this template supports JSX syntax with Tailwind CSS classes, React hooks, and Lucide React for icons. Do not install other packages for UI themes, icons, etc unless absolutely necessary or I request them.

Use icons from lucide-react for logos.
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.env
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);
</file>

<file path="index.html">
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Турнирная сетка</title>
    <meta name="description" content="Приложение для организации турнирных сеток" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "tournament-bracket-app",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "dev:mock": "vite",
    "mock:server": "json-server --watch src/mocks/data.json --port 4000",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"src/**/*.{ts,tsx}\"",
    "preview": "vite preview",
    "test": "jest --watchAll",
    "test:ci": "jest --ci --coverage --coverageReporters=text-lcov",
    "cy:open": "cypress open",
    "cy:run": "cypress run"
  },
  "dependencies": {
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.22.3",
    "react-toastify": "^10.0.4",
    "msw": "^2.2.3",
    "date-fns": "^3.3.1",
    "uuid": "^9.0.1",
    "@types/uuid": "^9.0.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2",
    "json-server": "^0.17.4"
  },
  "msw": {
    "workerDirectory": [
      "public"
    ]
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="public/mockServiceWorker.js">
/* eslint-disable */
/* tslint:disable */

/**
 * Mock Service Worker.
 * @see https://github.com/mswjs/msw
 * - Please do NOT modify this file.
 * - Please do NOT serve this file on production.
 */

const PACKAGE_VERSION = '2.8.4'
const INTEGRITY_CHECKSUM = '00729d72e3b82faf54ca8b9621dbb96f'
const IS_MOCKED_RESPONSE = Symbol('isMockedResponse')
const activeClientIds = new Set()

self.addEventListener('install', function () {
  self.skipWaiting()
})

self.addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim())
})

self.addEventListener('message', async function (event) {
  const clientId = event.source.id

  if (!clientId || !self.clients) {
    return
  }

  const client = await self.clients.get(clientId)

  if (!client) {
    return
  }

  const allClients = await self.clients.matchAll({
    type: 'window',
  })

  switch (event.data) {
    case 'KEEPALIVE_REQUEST': {
      sendToClient(client, {
        type: 'KEEPALIVE_RESPONSE',
      })
      break
    }

    case 'INTEGRITY_CHECK_REQUEST': {
      sendToClient(client, {
        type: 'INTEGRITY_CHECK_RESPONSE',
        payload: {
          packageVersion: PACKAGE_VERSION,
          checksum: INTEGRITY_CHECKSUM,
        },
      })
      break
    }

    case 'MOCK_ACTIVATE': {
      activeClientIds.add(clientId)

      sendToClient(client, {
        type: 'MOCKING_ENABLED',
        payload: {
          client: {
            id: client.id,
            frameType: client.frameType,
          },
        },
      })
      break
    }

    case 'MOCK_DEACTIVATE': {
      activeClientIds.delete(clientId)
      break
    }

    case 'CLIENT_CLOSED': {
      activeClientIds.delete(clientId)

      const remainingClients = allClients.filter((client) => {
        return client.id !== clientId
      })

      // Unregister itself when there are no more clients
      if (remainingClients.length === 0) {
        self.registration.unregister()
      }

      break
    }
  }
})

self.addEventListener('fetch', function (event) {
  const { request } = event

  // Bypass navigation requests.
  if (request.mode === 'navigate') {
    return
  }

  // Opening the DevTools triggers the "only-if-cached" request
  // that cannot be handled by the worker. Bypass such requests.
  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
    return
  }

  // Bypass all requests when there are no active clients.
  // Prevents the self-unregistered worked from handling requests
  // after it's been deleted (still remains active until the next reload).
  if (activeClientIds.size === 0) {
    return
  }

  // Generate unique request ID.
  const requestId = crypto.randomUUID()
  event.respondWith(handleRequest(event, requestId))
})

async function handleRequest(event, requestId) {
  const client = await resolveMainClient(event)
  const response = await getResponse(event, client, requestId)

  // Send back the response clone for the "response:*" life-cycle events.
  // Ensure MSW is active and ready to handle the message, otherwise
  // this message will pend indefinitely.
  if (client && activeClientIds.has(client.id)) {
    ;(async function () {
      const responseClone = response.clone()

      sendToClient(
        client,
        {
          type: 'RESPONSE',
          payload: {
            requestId,
            isMockedResponse: IS_MOCKED_RESPONSE in response,
            type: responseClone.type,
            status: responseClone.status,
            statusText: responseClone.statusText,
            body: responseClone.body,
            headers: Object.fromEntries(responseClone.headers.entries()),
          },
        },
        [responseClone.body],
      )
    })()
  }

  return response
}

// Resolve the main client for the given event.
// Client that issues a request doesn't necessarily equal the client
// that registered the worker. It's with the latter the worker should
// communicate with during the response resolving phase.
async function resolveMainClient(event) {
  const client = await self.clients.get(event.clientId)

  if (activeClientIds.has(event.clientId)) {
    return client
  }

  if (client?.frameType === 'top-level') {
    return client
  }

  const allClients = await self.clients.matchAll({
    type: 'window',
  })

  return allClients
    .filter((client) => {
      // Get only those clients that are currently visible.
      return client.visibilityState === 'visible'
    })
    .find((client) => {
      // Find the client ID that's recorded in the
      // set of clients that have registered the worker.
      return activeClientIds.has(client.id)
    })
}

async function getResponse(event, client, requestId) {
  const { request } = event

  // Clone the request because it might've been already used
  // (i.e. its body has been read and sent to the client).
  const requestClone = request.clone()

  function passthrough() {
    // Cast the request headers to a new Headers instance
    // so the headers can be manipulated with.
    const headers = new Headers(requestClone.headers)

    // Remove the "accept" header value that marked this request as passthrough.
    // This prevents request alteration and also keeps it compliant with the
    // user-defined CORS policies.
    const acceptHeader = headers.get('accept')
    if (acceptHeader) {
      const values = acceptHeader.split(',').map((value) => value.trim())
      const filteredValues = values.filter(
        (value) => value !== 'msw/passthrough',
      )

      if (filteredValues.length > 0) {
        headers.set('accept', filteredValues.join(', '))
      } else {
        headers.delete('accept')
      }
    }

    return fetch(requestClone, { headers })
  }

  // Bypass mocking when the client is not active.
  if (!client) {
    return passthrough()
  }

  // Bypass initial page load requests (i.e. static assets).
  // The absence of the immediate/parent client in the map of the active clients
  // means that MSW hasn't dispatched the "MOCK_ACTIVATE" event yet
  // and is not ready to handle requests.
  if (!activeClientIds.has(client.id)) {
    return passthrough()
  }

  // Notify the client that a request has been intercepted.
  const requestBuffer = await request.arrayBuffer()
  const clientMessage = await sendToClient(
    client,
    {
      type: 'REQUEST',
      payload: {
        id: requestId,
        url: request.url,
        mode: request.mode,
        method: request.method,
        headers: Object.fromEntries(request.headers.entries()),
        cache: request.cache,
        credentials: request.credentials,
        destination: request.destination,
        integrity: request.integrity,
        redirect: request.redirect,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        body: requestBuffer,
        keepalive: request.keepalive,
      },
    },
    [requestBuffer],
  )

  switch (clientMessage.type) {
    case 'MOCK_RESPONSE': {
      return respondWithMock(clientMessage.data)
    }

    case 'PASSTHROUGH': {
      return passthrough()
    }
  }

  return passthrough()
}

function sendToClient(client, message, transferrables = []) {
  return new Promise((resolve, reject) => {
    const channel = new MessageChannel()

    channel.port1.onmessage = (event) => {
      if (event.data && event.data.error) {
        return reject(event.data.error)
      }

      resolve(event.data)
    }

    client.postMessage(
      message,
      [channel.port2].concat(transferrables.filter(Boolean)),
    )
  })
}

async function respondWithMock(response) {
  // Setting response status code to 0 is a no-op.
  // However, when responding with a "Response.error()", the produced Response
  // instance will have status code set to 0. Since it's not possible to create
  // a Response instance with status code 0, handle that use-case separately.
  if (response.status === 0) {
    return Response.error()
  }

  const mockedResponse = new Response(response.body, response)

  Reflect.defineProperty(mockedResponse, IS_MOCKED_RESPONSE, {
    value: true,
    enumerable: true,
  })

  return mockedResponse
}
</file>

<file path="src/api/tournaments.ts">
import { Tournament, TournamentFormData } from '../types/tournament';

// Base API URL with explicit path
const API_URL = import.meta.env.DEV ? '/api/tournaments' : '/api/tournaments';

// Get all tournaments
export const getAllTournaments = async (): Promise<Tournament[]> => {
  try {
    const response = await fetch(API_URL);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      throw new Error('Response is not JSON');
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching tournaments:', error);
    throw error;
  }
};

// Get tournament by ID
export const getTournamentById = async (id: string): Promise<Tournament> => {
  try {
    const response = await fetch(`${API_URL}/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(`Error fetching tournament with ID ${id}:`, error);
    throw error;
  }
};

// Create new tournament
export const createTournament = async (tournamentData: TournamentFormData): Promise<Tournament> => {
  try {
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(tournamentData),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error! Status: ${response.status}, Details: ${errorText}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error creating tournament:', error);
    throw error;
  }
};

// Update tournament
export const updateTournament = async (id: string, tournamentData: Partial<Tournament>): Promise<Tournament> => {
  try {
    const response = await fetch(`${API_URL}/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(tournamentData),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(`Error updating tournament with ID ${id}:`, error);
    throw error;
  }
};

// Update match score
export const updateMatchScore = async (
  tournamentId: string, 
  matchId: string, 
  score1: number, 
  score2: number
): Promise<void> => {
  try {
    // First get current tournament data
    const tournament = await getTournamentById(tournamentId);
    
    // Update score for the specified match
    const updatedRounds = tournament.rounds.map(round => {
      const updatedMatches = round.matches.map(match => {
        if (match.id === matchId) {
          return { ...match, score1, score2 };
        }
        return match;
      });
      
      return { ...round, matches: updatedMatches };
    });
    
    // Send updated tournament
    await updateTournament(tournamentId, { rounds: updatedRounds });
  } catch (error) {
    console.error(`Error updating match score for tournament ${tournamentId}, match ${matchId}:`, error);
    throw error;
  }
};

// Delete tournament
export const deleteTournament = async (id: string): Promise<void> => {
  try {
    const response = await fetch(`${API_URL}/${id}`, {
      method: 'DELETE',
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
  } catch (error) {
    console.error(`Error deleting tournament with ID ${id}:`, error);
    throw error;
  }
};
</file>

<file path="src/App.tsx">
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

import Layout from './components/Layout';
import DashboardPage from './pages/DashboardPage';
import TournamentFormPage from './pages/TournamentFormPage';
import BracketPage from './pages/BracketPage';
import TournamentEditPage from './pages/TournamentEditPage';
import TournamentSettingsPage from './pages/TournamentSettingsPage';
import AboutPage from './pages/AboutPage';
import NotFoundPage from './pages/NotFoundPage';

function App() {
  return (
    <>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<DashboardPage />} />
          <Route path="tournaments/new" element={<TournamentFormPage />} />
          <Route path="tournaments/:id" element={<BracketPage />} />
          <Route path="tournaments/:id/edit" element={<TournamentEditPage />} />
          <Route path="tournaments/:id/settings" element={<TournamentSettingsPage />} />
          <Route path="about" element={<AboutPage />} />
          <Route path="*" element={<NotFoundPage />} />
        </Route>
      </Routes>
      <ToastContainer position="bottom-right" />
    </>
  );
}

export default App;
</file>

<file path="src/components/BracketGrid.tsx">
import React, { useState } from 'react';
import { ChevronRight, ChevronLeft } from 'lucide-react';
import Button from './Button';
import { Match, Round, Tournament } from '../types/tournament';
import MatchCard from './MatchCard';

interface BracketGridProps {
  tournament: Tournament;
  onScoreUpdate?: (matchId: string, score1: number, score2: number) => void;
}

const BracketGrid: React.FC<BracketGridProps> = ({ tournament, onScoreUpdate }) => {
  const [scrollPosition, setScrollPosition] = useState(0);
  const scrollRef = React.useRef<HTMLDivElement>(null);

  const handleScrollLeft = () => {
    if (scrollRef.current) {
      const newPosition = scrollPosition - 300;
      scrollRef.current.scrollTo({
        left: newPosition,
        behavior: 'smooth'
      });
      setScrollPosition(Math.max(0, newPosition));
    }
  };

  const handleScrollRight = () => {
    if (scrollRef.current) {
      const newPosition = scrollPosition + 300;
      scrollRef.current.scrollTo({
        left: newPosition,
        behavior: 'smooth'
      });
      setScrollPosition(newPosition);
    }
  };

  return (
    <div className="relative">
      <div className="flex justify-between mb-4">
        <h2 className="text-xl font-semibold">Сетка турнира</h2>
        <div className="flex space-x-2">
          <Button
            variant="secondary"
            size="sm"
            onClick={handleScrollLeft}
            leftIcon={<ChevronLeft size={16} />}
          >
            Назад
          </Button>
          <Button
            variant="secondary"
            size="sm"
            onClick={handleScrollRight}
            rightIcon={<ChevronRight size={16} />}
          >
            Вперед
          </Button>
        </div>
      </div>

      <div 
        ref={scrollRef}
        className="bracket-container pb-4"
        style={{ overflowX: 'auto' }}
      >
        {tournament.rounds.map((round, roundIndex) => (
          <div key={round.id} className="bracket-round">
            <div className="text-center mb-4 sticky top-0 bg-gray-50 py-2">
              <h3 className="text-sm font-medium text-gray-600">
                {round.name}
              </h3>
            </div>
            
            <div className="flex flex-col justify-around h-full">
              {round.matches.map((match) => (
                <MatchCard 
                  key={match.id} 
                  match={match} 
                  roundIndex={roundIndex}
                  onScoreUpdate={onScoreUpdate}
                />
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default BracketGrid;
</file>

<file path="src/components/Button.tsx">
import React, { ButtonHTMLAttributes } from 'react';

type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'ghost';
type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  size = 'md',
  isLoading = false,
  leftIcon,
  rightIcon,
  className = '',
  disabled,
  ...props
}) => {
  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors';
  
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 disabled:bg-blue-300',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-400 disabled:bg-gray-100 disabled:text-gray-400',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 disabled:bg-red-300',
    ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 focus:ring-gray-300 disabled:text-gray-300'
  };
  
  const sizeClasses = {
    sm: 'text-xs px-2 py-1',
    md: 'text-sm px-4 py-2',
    lg: 'text-base px-6 py-3'
  };
  
  const classes = `
    ${baseClasses}
    ${variantClasses[variant]}
    ${sizeClasses[size]}
    ${disabled || isLoading ? 'cursor-not-allowed' : ''}
    ${className}
  `;
  
  return (
    <button
      className={classes}
      disabled={disabled || isLoading}
      {...props}
    >
      {isLoading && (
        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      )}
      {!isLoading && leftIcon && <span className="mr-2">{leftIcon}</span>}
      {children}
      {!isLoading && rightIcon && <span className="ml-2">{rightIcon}</span>}
    </button>
  );
};

export default Button;
</file>

<file path="src/components/ExportOptions.tsx">
import React, { useState } from 'react';
import { Download } from 'lucide-react';
import Button from './Button';
import { Tournament } from '../types/tournament';

interface ExportOptionsProps {
  tournament: Tournament;
}

const ExportOptions: React.FC<ExportOptionsProps> = ({ tournament }) => {
  const [isExporting, setIsExporting] = useState(false);
  
  const downloadFile = (content: string, filename: string, contentType: string) => {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  const exportAsJSON = () => {
    setIsExporting(true);
    try {
      const content = JSON.stringify(tournament, null, 2);
      const filename = `tournament-${tournament.id}-${new Date().toISOString().slice(0, 10)}.json`;
      downloadFile(content, filename, 'application/json');
    } catch (error) {
      console.error('Error exporting as JSON:', error);
    } finally {
      setIsExporting(false);
    }
  };
  
  const exportAsCSV = () => {
    setIsExporting(true);
    try {
      // Преобразуем данные турнира в CSV
      const tournamentData = [
        ['ID', 'Name', 'Type', 'Status', 'Start Date', 'Max Participants'],
        [
          tournament.id, 
          tournament.name, 
          tournament.bracketType, 
          tournament.status, 
          tournament.startDate, 
          tournament.maxParticipants
        ]
      ];
      
      // Добавляем информацию о матчах
      const matchesData = [
        ['Round', 'Match ID', 'Participant 1', 'Participant 2', 'Score 1', 'Score 2']
      ];
      
      tournament.rounds.forEach(round => {
        round.matches.forEach(match => {
          matchesData.push([
            round.name,
            match.id,
            match.participant1 || 'TBD',
            match.participant2 || 'TBD',
            match.score1?.toString() || '',
            match.score2?.toString() || ''
          ]);
        });
      });
      
      // Объединяем данные
      const allData = [
        ['Tournament Info'],
        ...tournamentData,
        [''],
        ['Matches'],
        ...matchesData
      ];
      
      // Преобразуем в CSV
      const csvContent = allData.map(row => row.join(',')).join('\n');
      const filename = `tournament-${tournament.id}-${new Date().toISOString().slice(0, 10)}.csv`;
      
      downloadFile(csvContent, filename, 'text/csv');
    } catch (error) {
      console.error('Error exporting as CSV:', error);
    } finally {
      setIsExporting(false);
    }
  };
  
  return (
    <div className="card mb-6">
      <h3 className="text-lg font-semibold mb-4">Экспорт данных</h3>
      
      <p className="text-sm text-gray-600 mb-4">
        Экспортируйте данные турнира для использования в других приложениях или для резервного копирования.
      </p>
      
      <div className="flex flex-col sm:flex-row gap-3">
        <Button
          variant="secondary"
          onClick={exportAsJSON}
          isLoading={isExporting}
          leftIcon={<Download size={16} />}
        >
          Экспорт в JSON
        </Button>
        
        <Button
          variant="secondary"
          onClick={exportAsCSV}
          isLoading={isExporting}
          leftIcon={<Download size={16} />}
        >
          Экспорт в CSV
        </Button>
      </div>
    </div>
  );
};

export default ExportOptions;
</file>

<file path="src/components/Footer.tsx">
import React from 'react';
import { Github } from 'lucide-react';

const Footer: React.FC = () => {
  return (
    <footer className="bg-gray-100 border-t border-gray-200 py-6">
      <div className="container mx-auto px-4">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <div className="mb-4 md:mb-0">
            <p className="text-sm text-gray-600">© 2025 ТурнирПро. Все права защищены.</p>
          </div>
          <div className="flex items-center space-x-4">
            <a href="#" className="text-gray-600 hover:text-blue-600 flex items-center">
              <Github className="h-5 w-5 mr-1" />
              <span className="text-sm">GitHub</span>
            </a>
            <a href="#" className="text-gray-600 hover:text-blue-600 text-sm">Документация API</a>
            <a href="#" className="text-gray-600 hover:text-blue-600 text-sm">Помощь</a>
          </div>
        </div>
      </div>
    </footer>
  );
};

export default Footer;
</file>

<file path="src/components/Input.tsx">
import React, { InputHTMLAttributes, forwardRef } from 'react';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  helperText?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, helperText, className = '', ...props }, ref) => {
    return (
      <div className="mb-4">
        {label && (
          <label 
            htmlFor={props.id} 
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            {label}
          </label>
        )}
        <input
          ref={ref}
          className={`block w-full px-3 py-2 border ${
            error ? 'border-red-500' : 'border-gray-300'
          } rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 ${className}`}
          {...props}
        />
        {error && (
          <p className="mt-1 text-sm text-red-600">{error}</p>
        )}
        {helperText && !error && (
          <p className="mt-1 text-sm text-gray-500">{helperText}</p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

export default Input;
</file>

<file path="src/components/Layout.tsx">
import React from 'react';
import { Outlet } from 'react-router-dom';
import Navbar from './Navbar';
import Footer from './Footer';

const Layout: React.FC = () => {
  return (
    <div className="min-h-screen flex flex-col">
      <Navbar />
      <main className="flex-grow container mx-auto px-4 py-8">
        <Outlet />
      </main>
      <Footer />
    </div>
  );
};

export default Layout;
</file>

<file path="src/components/MatchCard.tsx">
import React, { useState } from 'react';
import { Edit2, Check, X } from 'lucide-react';
import { Match } from '../types/tournament';
import Button from './Button';

interface MatchCardProps {
  match: Match;
  roundIndex: number;
  onScoreUpdate?: (matchId: string, score1: number, score2: number) => void;
}

const MatchCard: React.FC<MatchCardProps> = ({ match, roundIndex, onScoreUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [score1, setScore1] = useState(match.score1?.toString() || '');
  const [score2, setScore2] = useState(match.score2?.toString() || '');

  const handleSaveScore = () => {
    if (onScoreUpdate) {
      onScoreUpdate(match.id, parseInt(score1) || 0, parseInt(score2) || 0);
    }
    setIsEditing(false);
  };

  const handleCancelEdit = () => {
    setScore1(match.score1?.toString() || '');
    setScore2(match.score2?.toString() || '');
    setIsEditing(false);
  };

  // Определяем статус матча
  const getMatchStatus = () => {
    if (!match.participant1 || !match.participant2) return 'Ожидание участников';
    if (match.score1 !== null && match.score2 !== null) return 'Завершен';
    return 'Не начался';
  };

  // Определяем цвет для статуса
  const getStatusColor = () => {
    const status = getMatchStatus();
    if (status === 'Завершен') return 'text-green-600';
    if (status === 'Не начался') return 'text-blue-600';
    return 'text-gray-500';
  };

  return (
    <div 
      className={`bracket-match ${isEditing ? 'bracket-match-active' : ''}`}
      style={{ 
        marginTop: roundIndex > 0 ? `${Math.pow(2, roundIndex) * 16}px` : '0', 
        marginBottom: roundIndex > 0 ? `${Math.pow(2, roundIndex) * 16}px` : '8px' 
      }}
    >
      <div className="flex justify-between items-center mb-3">
        <span className={`text-xs font-medium ${getStatusColor()}`}>
          {getMatchStatus()}
        </span>
        {!isEditing && (
          <button 
            onClick={() => setIsEditing(true)}
            className="text-gray-400 hover:text-blue-600"
            title="Редактировать счет"
          >
            <Edit2 size={14} />
          </button>
        )}
      </div>
      
      <div className="space-y-3">
        <div className="flex justify-between items-center">
          <span className="font-medium">{match.participant1 || 'TBD'}</span>
          {!isEditing ? (
            <span className="font-bold">{match.score1 ?? '-'}</span>
          ) : (
            <input 
              type="number" 
              min="0"
              value={score1} 
              onChange={(e) => setScore1(e.target.value)}
              className="w-12 text-center border border-gray-300 rounded"
            />
          )}
        </div>
        
        <div className="flex justify-between items-center">
          <span className="font-medium">{match.participant2 || 'TBD'}</span>
          {!isEditing ? (
            <span className="font-bold">{match.score2 ?? '-'}</span>
          ) : (
            <input 
              type="number"
              min="0"
              value={score2} 
              onChange={(e) => setScore2(e.target.value)}
              className="w-12 text-center border border-gray-300 rounded"
            />
          )}
        </div>
      </div>
      
      {isEditing && (
        <div className="flex justify-end space-x-2 mt-3">
          <Button 
            size="sm" 
            variant="ghost"
            onClick={handleCancelEdit}
            leftIcon={<X size={14} />}
          >
            Отмена
          </Button>
          <Button 
            size="sm" 
            variant="primary"
            onClick={handleSaveScore}
            leftIcon={<Check size={14} />}
          >
            Сохранить
          </Button>
        </div>
      )}
    </div>
  );
};

export default MatchCard;
</file>

<file path="src/components/Navbar.tsx">
import React from 'react';
import { NavLink, Link } from 'react-router-dom';
import { Trophy } from 'lucide-react';

const Navbar: React.FC = () => {
  return (
    <header className="bg-white shadow-sm sticky top-0 z-10">
      <div className="container mx-auto px-4">
        <div className="flex justify-between items-center h-16">
          <Link to="/" className="flex items-center space-x-3">
            <Trophy className="h-8 w-8 text-blue-600" />
            <span className="font-bold text-xl">ТурнирПро</span>
          </Link>
          
          <nav className="hidden md:flex space-x-8">
            <NavLink 
              to="/" 
              className={({ isActive }) => 
                `text-sm font-medium ${isActive ? 'text-blue-600' : 'text-gray-700 hover:text-blue-600'}`
              }
              end
            >
              Главная
            </NavLink>
            <NavLink 
              to="/tournaments/new" 
              className={({ isActive }) => 
                `text-sm font-medium ${isActive ? 'text-blue-600' : 'text-gray-700 hover:text-blue-600'}`
              }
            >
              Создать турнир
            </NavLink>
            <NavLink 
              to="/about" 
              className={({ isActive }) => 
                `text-sm font-medium ${isActive ? 'text-blue-600' : 'text-gray-700 hover:text-blue-600'}`
              }
            >
              О проекте
            </NavLink>
          </nav>
          
          <div className="md:hidden">
            <button className="p-2 text-gray-700 rounded-md">
              <svg 
                xmlns="http://www.w3.org/2000/svg" 
                className="h-6 w-6" 
                fill="none" 
                viewBox="0 0 24 24" 
                stroke="currentColor"
              >
                <path 
                  strokeLinecap="round" 
                  strokeLinejoin="round" 
                  strokeWidth={2} 
                  d="M4 6h16M4 12h16M4 18h16" 
                />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </header>
  );
};

export default Navbar;
</file>

<file path="src/components/Select.tsx">
import React, { SelectHTMLAttributes, forwardRef } from 'react';

interface SelectOption {
  value: string;
  label: string;
}

interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  label?: string;
  options: SelectOption[];
  error?: string;
  helperText?: string;
}

const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ label, options, error, helperText, className = '', ...props }, ref) => {
    return (
      <div className="mb-4">
        {label && (
          <label 
            htmlFor={props.id} 
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            {label}
          </label>
        )}
        <select
          ref={ref}
          className={`block w-full px-3 py-2 border ${
            error ? 'border-red-500' : 'border-gray-300'
          } rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 ${className}`}
          {...props}
        >
          {options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        {error && (
          <p className="mt-1 text-sm text-red-600">{error}</p>
        )}
        {helperText && !error && (
          <p className="mt-1 text-sm text-gray-500">{helperText}</p>
        )}
      </div>
    );
  }
);

Select.displayName = 'Select';

export default Select;
</file>

<file path="src/components/TournamentCard.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Calendar, Users, Edit, Settings, Trash } from 'lucide-react';
import { Tournament } from '../types/tournament';
import { formatDate } from '../utils/dateUtils';
import Button from './Button';

interface TournamentCardProps {
  tournament: Tournament;
  onDelete: (id: string) => void;
}

const TournamentCard: React.FC<TournamentCardProps> = ({ tournament, onDelete }) => {
  const navigate = useNavigate();
  
  const getStatusBadge = (status: string) => {
    switch (status) {
      case 'active':
        return <span className="tournament-status-active">Активный</span>;
      case 'pending':
        return <span className="tournament-status-pending">Ожидание</span>;
      case 'completed':
        return <span className="tournament-status-completed">Завершен</span>;
      case 'cancelled':
        return <span className="tournament-status-cancelled">Отменен</span>;
      default:
        return null;
    }
  };
  
  return (
    <div className="card hover:shadow-lg transition-shadow">
      <div className="flex justify-between items-start">
        <h3 className="text-xl font-medium">{tournament.name}</h3>
        {getStatusBadge(tournament.status)}
      </div>
      
      <div className="mt-4 space-y-2">
        <div className="flex items-center text-gray-600">
          <Calendar size={16} className="mr-2" />
          <span className="text-sm">{formatDate(tournament.startDate)}</span>
        </div>
        
        <div className="flex items-center text-gray-600">
          <Users size={16} className="mr-2" />
          <span className="text-sm">Участников: {tournament.participantsCount}</span>
        </div>
      </div>
      
      <div className="mt-6 flex justify-between items-center">
        <Button 
          variant="primary"
          onClick={() => navigate(`/tournaments/${tournament.id}`)}
        >
          Просмотр сетки
        </Button>
        
        <div className="flex space-x-2">
          <Button 
            variant="ghost" 
            size="sm"
            onClick={() => navigate(`/tournaments/${tournament.id}/edit`)}
            title="Редактировать"
          >
            <Edit size={16} />
          </Button>
          <Button 
            variant="ghost" 
            size="sm"
            onClick={() => navigate(`/tournaments/${tournament.id}/settings`)}
            title="Настройки"
          >
            <Settings size={16} />
          </Button>
          <Button 
            variant="ghost" 
            size="sm"
            onClick={() => onDelete(tournament.id)}
            title="Удалить"
          >
            <Trash size={16} className="text-red-500" />
          </Button>
        </div>
      </div>
    </div>
  );
};

export default TournamentCard;
</file>

<file path="src/components/TournamentForm.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Check, X } from 'lucide-react';
import Button from './Button';
import Input from './Input';
import Select from './Select';
import { Tournament } from '../types/tournament';

interface TournamentFormProps {
  initialData?: Tournament;
  onSubmit: (data: Partial<Tournament>) => Promise<void>;
  isEditing?: boolean;
}

const bracketTypes = [
  { value: 'single-elimination', label: 'Олимпийская система (Single Elimination)' },
  { value: 'double-elimination', label: 'Двойное выбывание (Double Elimination)' },
  { value: 'round-robin', label: 'Круговая система (Round Robin)' },
  { value: 'swiss', label: 'Швейцарская система (Swiss)' },
];

const TournamentForm: React.FC<TournamentFormProps> = ({ 
  initialData, 
  onSubmit,
  isEditing = false
}) => {
  const navigate = useNavigate();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formData, setFormData] = useState<Partial<Tournament>>(
    initialData || {
      name: '',
      bracketType: 'single-elimination',
      maxParticipants: 8,
      startDate: new Date().toISOString().split('T')[0],
      rules: '',
      status: 'pending'
    }
  );
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const validate = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.name?.trim()) {
      newErrors.name = 'Название турнира обязательно';
    }
    
    if (!formData.maxParticipants || formData.maxParticipants < 2) {
      newErrors.maxParticipants = 'Минимум 2 участника';
    }
    
    if (!formData.startDate) {
      newErrors.startDate = 'Дата начала обязательна';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    let parsedValue: string | number = value;
    
    if (name === 'maxParticipants') {
      parsedValue = parseInt(value) || 0;
    }
    
    setFormData(prev => ({
      ...prev,
      [name]: parsedValue
    }));
    
    // Очищаем ошибку при изменении поля
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validate()) return;
    
    setIsSubmitting(true);
    
    try {
      await onSubmit(formData);
      navigate('/');
    } catch (error) {
      console.error('Error submitting form:', error);
      // Можно добавить отображение ошибки
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="max-w-3xl mx-auto">
      <div className="card">
        <h2 className="text-2xl font-semibold mb-6">
          {isEditing ? 'Редактирование турнира' : 'Создание нового турнира'}
        </h2>
        
        <Input
          label="Название турнира"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Например: Чемпионат по шахматам 2025"
          error={errors.name}
          required
        />
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <Select
            label="Тип турнирной сетки"
            id="bracketType"
            name="bracketType"
            value={formData.bracketType}
            onChange={handleChange}
            options={bracketTypes}
          />
          
          <Input
            label="Максимальное количество участников"
            id="maxParticipants"
            name="maxParticipants"
            type="number"
            min="2"
            max="128"
            value={formData.maxParticipants?.toString()}
            onChange={handleChange}
            error={errors.maxParticipants}
            required
          />
        </div>
        
        <Input
          label="Дата начала"
          id="startDate"
          name="startDate"
          type="date"
          value={formData.startDate}
          onChange={handleChange}
          error={errors.startDate}
          required
        />
        
        <div className="mb-4">
          <label htmlFor="rules" className="block text-sm font-medium text-gray-700 mb-1">
            Правила турнира
          </label>
          <textarea
            id="rules"
            name="rules"
            rows={4}
            value={formData.rules}
            onChange={handleChange}
            placeholder="Опишите правила проведения турнира..."
            className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
        
        <div className="flex justify-end space-x-4 mt-6">
          <Button
            type="button"
            variant="secondary"
            onClick={() => navigate('/')}
            leftIcon={<X size={16} />}
          >
            Отмена
          </Button>
          <Button
            type="submit"
            variant="primary"
            isLoading={isSubmitting}
            leftIcon={<Check size={16} />}
          >
            {isEditing ? 'Сохранить изменения' : 'Создать турнир'}
          </Button>
        </div>
      </div>
    </form>
  );
};

export default TournamentForm;
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-family: 'Inter', system-ui, sans-serif;
  }
  
  body {
    @apply bg-gray-50 text-gray-900;
  }
  
  h1, h2, h3, h4, h5, h6 {
    @apply font-medium leading-tight;
  }
  
  h1 {
    @apply text-3xl mb-6;
  }
  
  h2 {
    @apply text-2xl mb-4;
  }
  
  h3 {
    @apply text-xl mb-3;
  }
}

@layer components {
  .btn {
    @apply px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2;
  }
  
  .btn-primary {
    @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500;
  }
  
  .btn-secondary {
    @apply bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-400;
  }
  
  .btn-danger {
    @apply bg-red-600 text-white hover:bg-red-700 focus:ring-red-500;
  }
  
  .form-input {
    @apply block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm 
           focus:outline-none focus:ring-blue-500 focus:border-blue-500;
  }
  
  .form-label {
    @apply block text-sm font-medium text-gray-700 mb-1;
  }
  
  .card {
    @apply bg-white rounded-lg shadow-md p-6;
  }
  
  .tournament-status-active {
    @apply text-green-700 bg-green-100 px-2 py-1 rounded-full text-xs font-medium;
  }
  
  .tournament-status-pending {
    @apply text-yellow-700 bg-yellow-100 px-2 py-1 rounded-full text-xs font-medium;
  }
  
  .tournament-status-completed {
    @apply text-blue-700 bg-blue-100 px-2 py-1 rounded-full text-xs font-medium;
  }
  
  .tournament-status-cancelled {
    @apply text-red-700 bg-red-100 px-2 py-1 rounded-full text-xs font-medium;
  }
}

.bracket-container {
  @apply flex overflow-x-auto pb-8;
}

.bracket-round {
  @apply flex flex-col justify-around min-w-64 px-4;
}

.bracket-match {
  @apply bg-white border border-gray-200 rounded-md p-4 mb-4 shadow-sm 
         hover:shadow-md transition-shadow cursor-pointer;
}

.bracket-match-active {
  @apply border-blue-500 ring-2 ring-blue-200;
}

/* Плавная анимация для переходов между страницами */
.page-transition-enter {
  opacity: 0;
  transform: translateY(10px);
}

.page-transition-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}

.page-transition-exit {
  opacity: 1;
  transform: translateY(0);
}

.page-transition-exit-active {
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 300ms, transform 300ms;
}
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

// Initialize mock server in development mode
async function startMockServiceWorker() {
  if (import.meta.env.DEV && typeof window !== 'undefined') {
    try {
      const { worker } = await import('./mocks/browser');
      // Ensure proper headers and response type
      await worker.start({
        onUnhandledRequest: 'bypass',
        serviceWorker: {
          url: '/mockServiceWorker.js',
          options: {
            scope: '/'
          }
        }
      });
      console.log('[MSW] Mock Service Worker started successfully');
    } catch (error) {
      console.error('[MSW] Failed to start Mock Service Worker:', error);
    }
  }
}

// Start the mock service worker before rendering the app
startMockServiceWorker().then(() => {
  const rootElement = document.getElementById('root');
  if (!rootElement) throw new Error('Root element not found');
  
  createRoot(rootElement).render(
    <StrictMode>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </StrictMode>
  );
}).catch(console.error);
</file>

<file path="src/mocks/browser.ts">
import { setupWorker } from 'msw/browser';
import { handlers } from './handlers';

// Setup Service Worker for MSW
export const worker = setupWorker(...handlers);
</file>

<file path="src/mocks/data.json">
{
  "tournaments": [
    {
      "id": "1",
      "name": "Чемпионат по шахматам 2025",
      "bracketType": "single-elimination",
      "status": "active",
      "startDate": "2025-06-15",
      "maxParticipants": 16,
      "participantsCount": 16,
      "rounds": [
        {
          "id": "1-r1",
          "name": "1/8 финала",
          "matches": [
            {
              "id": "1-r1-m1",
              "participant1": "Иванов И.",
              "participant2": "Петров П.",
              "score1": 1,
              "score2": 0,
              "nextMatchId": "1-r2-m1"
            },
            {
              "id": "1-r1-m2",
              "participant1": "Сидоров С.",
              "participant2": "Смирнов С.",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "1-r2-m1"
            },
            {
              "id": "1-r1-m3",
              "participant1": "Козлов К.",
              "participant2": "Новиков Н.",
              "score1": 1,
              "score2": 0,
              "nextMatchId": "1-r2-m2"
            },
            {
              "id": "1-r1-m4",
              "participant1": "Морозов М.",
              "participant2": "Волков В.",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "1-r2-m2"
            },
            {
              "id": "1-r1-m5",
              "participant1": "Алексеев А.",
              "participant2": "Лебедев Л.",
              "score1": 1,
              "score2": 0,
              "nextMatchId": "1-r2-m3"
            },
            {
              "id": "1-r1-m6",
              "participant1": "Семенов С.",
              "participant2": "Егоров Е.",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "1-r2-m3"
            },
            {
              "id": "1-r1-m7",
              "participant1": "Павлов П.",
              "participant2": "Козлов К.",
              "score1": 1,
              "score2": 0,
              "nextMatchId": "1-r2-m4"
            },
            {
              "id": "1-r1-m8",
              "participant1": "Степанов С.",
              "participant2": "Николаев Н.",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "1-r2-m4"
            }
          ]
        },
        {
          "id": "1-r2",
          "name": "1/4 финала",
          "matches": [
            {
              "id": "1-r2-m1",
              "participant1": "Иванов И.",
              "participant2": "Смирнов С.",
              "score1": 1,
              "score2": 0,
              "nextMatchId": "1-r3-m1"
            },
            {
              "id": "1-r2-m2",
              "participant1": "Козлов К.",
              "participant2": "Волков В.",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "1-r3-m1"
            },
            {
              "id": "1-r2-m3",
              "participant1": "Алексеев А.",
              "participant2": "Егоров Е.",
              "score1": null,
              "score2": null,
              "nextMatchId": "1-r3-m2"
            },
            {
              "id": "1-r2-m4",
              "participant1": "Павлов П.",
              "participant2": "Николаев Н.",
              "score1": null,
              "score2": null,
              "nextMatchId": "1-r3-m2"
            }
          ]
        },
        {
          "id": "1-r3",
          "name": "1/2 финала",
          "matches": [
            {
              "id": "1-r3-m1",
              "participant1": "Иванов И.",
              "participant2": "Волков В.",
              "score1": null,
              "score2": null,
              "nextMatchId": "1-r4-m1"
            },
            {
              "id": "1-r3-m2",
              "participant1": null,
              "participant2": null,
              "score1": null,
              "score2": null,
              "nextMatchId": "1-r4-m1"
            }
          ]
        },
        {
          "id": "1-r4",
          "name": "Финал",
          "matches": [
            {
              "id": "1-r4-m1",
              "participant1": null,
              "participant2": null,
              "score1": null,
              "score2": null
            }
          ]
        }
      ],
      "rules": "Турнир проводится по олимпийской системе. Каждый матч играется до первой победы.",
      "createdAt": "2024-05-01T10:00:00Z",
      "updatedAt": "2024-05-10T15:30:00Z"
    },
    {
      "id": "2",
      "name": "Турнир по теннису \"Весна 2025\"",
      "bracketType": "single-elimination",
      "status": "pending",
      "startDate": "2025-05-10",
      "maxParticipants": 8,
      "participantsCount": 6,
      "rounds": [
        {
          "id": "2-r1",
          "name": "1/4 финала",
          "matches": [
            {
              "id": "2-r1-m1",
              "participant1": "Федоров Ф.",
              "participant2": "Зайцев З.",
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r2-m1"
            },
            {
              "id": "2-r1-m2",
              "participant1": "Макаров М.",
              "participant2": "Андреев А.",
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r2-m1"
            },
            {
              "id": "2-r1-m3",
              "participant1": "Тарасов Т.",
              "participant2": "Соколов С.",
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r2-m2"
            },
            {
              "id": "2-r1-m4",
              "participant1": "Кузнецов К.",
              "participant2": null,
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r2-m2"
            }
          ]
        },
        {
          "id": "2-r2",
          "name": "1/2 финала",
          "matches": [
            {
              "id": "2-r2-m1",
              "participant1": null,
              "participant2": null,
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r3-m1"
            },
            {
              "id": "2-r2-m2",
              "participant1": null,
              "participant2": null,
              "score1": null,
              "score2": null,
              "nextMatchId": "2-r3-m1"
            }
          ]
        },
        {
          "id": "2-r3",
          "name": "Финал",
          "matches": [
            {
              "id": "2-r3-m1",
              "participant1": null,
              "participant2": null,
              "score1": null,
              "score2": null
            }
          ]
        }
      ],
      "rules": "Турнир проводится по олимпийской системе. Каждый матч играется до двух побед.",
      "createdAt": "2024-04-15T09:30:00Z",
      "updatedAt": "2024-04-20T11:45:00Z"
    },
    {
      "id": "3",
      "name": "Кубок по футболу 2025",
      "bracketType": "double-elimination",
      "status": "completed",
      "startDate": "2025-07-05",
      "endDate": "2025-07-20",
      "maxParticipants": 16,
      "participantsCount": 16,
      "rounds": [
        {
          "id": "3-r1",
          "name": "1/8 финала",
          "matches": [
            {
              "id": "3-r1-m1",
              "participant1": "Команда А",
              "participant2": "Команда Б",
              "score1": 2,
              "score2": 1,
              "nextMatchId": "3-r2-m1"
            },
            {
              "id": "3-r1-m2",
              "participant1": "Команда В",
              "participant2": "Команда Г",
              "score1": 3,
              "score2": 0,
              "nextMatchId": "3-r2-m1"
            },
            {
              "id": "3-r1-m3",
              "participant1": "Команда Д",
              "participant2": "Команда Е",
              "score1": 1,
              "score2": 1,
              "nextMatchId": "3-r2-m2"
            },
            {
              "id": "3-r1-m4",
              "participant1": "Команда Ж",
              "participant2": "Команда З",
              "score1": 0,
              "score2": 2,
              "nextMatchId": "3-r2-m2"
            },
            {
              "id": "3-r1-m5",
              "participant1": "Команда И",
              "participant2": "Команда К",
              "score1": 4,
              "score2": 2,
              "nextMatchId": "3-r2-m3"
            },
            {
              "id": "3-r1-m6",
              "participant1": "Команда Л",
              "participant2": "Команда М",
              "score1": 1,
              "score2": 2,
              "nextMatchId": "3-r2-m3"
            },
            {
              "id": "3-r1-m7",
              "participant1": "Команда Н",
              "participant2": "Команда О",
              "score1": 3,
              "score2": 3,
              "nextMatchId": "3-r2-m4"
            },
            {
              "id": "3-r1-m8",
              "participant1": "Команда П",
              "participant2": "Команда Р",
              "score1": 2,
              "score2": 0,
              "nextMatchId": "3-r2-m4"
            }
          ]
        },
        {
          "id": "3-r2",
          "name": "1/4 финала",
          "matches": [
            {
              "id": "3-r2-m1",
              "participant1": "Команда А",
              "participant2": "Команда В",
              "score1": 1,
              "score2": 2,
              "nextMatchId": "3-r3-m1"
            },
            {
              "id": "3-r2-m2",
              "participant1": "Команда Д",
              "participant2": "Команда З",
              "score1": 0,
              "score2": 1,
              "nextMatchId": "3-r3-m1"
            },
            {
              "id": "3-r2-m3",
              "participant1": "Команда И",
              "participant2": "Команда М",
              "score1": 3,
              "score2": 1,
              "nextMatchId": "3-r3-m2"
            },
            {
              "id": "3-r2-m4",
              "participant1": "Команда Н",
              "participant2": "Команда П",
              "score1": 2,
              "score2": 2,
              "nextMatchId": "3-r3-m2"
            }
          ]
        },
        {
          "id": "3-r3",
          "name": "1/2 финала",
          "matches": [
            {
              "id": "3-r3-m1",
              "participant1": "Команда В",
              "participant2": "Команда З",
              "score1": 2,
              "score2": 0,
              "nextMatchId": "3-r4-m1"
            },
            {
              "id": "3-r3-m2",
              "participant1": "Команда И",
              "participant2": "Команда Н",
              "score1": 1,
              "score2": 2,
              "nextMatchId": "3-r4-m1"
            }
          ]
        },
        {
          "id": "3-r4",
          "name": "Финал",
          "matches": [
            {
              "id": "3-r4-m1",
              "participant1": "Команда В",
              "participant2": "Команда Н",
              "score1": 3,
              "score2": 1
            }
          ]
        }
      ],
      "rules": "Турнир проводится по олимпийской системе. Если в основное время матч заканчивается вничью, назначается серия пенальти.",
      "createdAt": "2024-03-10T08:15:00Z",
      "updatedAt": "2024-03-25T14:20:00Z"
    }
  ]
}
</file>

<file path="src/mocks/handlers.ts">
import { http, HttpResponse, delay } from 'msw';
import { v4 as uuidv4 } from 'uuid';
import { Tournament, TournamentFormData } from '../types/tournament';

// Initial mock data for tournaments
let tournaments: Tournament[] = [
  {
    id: '1',
    name: 'Чемпионат по шахматам 2025',
    bracketType: 'single-elimination',
    status: 'active',
    startDate: '2025-06-15',
    maxParticipants: 16,
    participantsCount: 16,
    rounds: [
      {
        id: '1-r1',
        name: '1/8 финала',
        matches: [
          {
            id: '1-r1-m1',
            participant1: 'Иванов И.',
            participant2: 'Петров П.',
            score1: 1,
            score2: 0,
            nextMatchId: '1-r2-m1'
          },
          {
            id: '1-r1-m2',
            participant1: 'Сидоров С.',
            participant2: 'Смирнов С.',
            score1: 0,
            score2: 1,
            nextMatchId: '1-r2-m1'
          },
          {
            id: '1-r1-m3',
            participant1: 'Козлов К.',
            participant2: 'Новиков Н.',
            score1: 1,
            score2: 0,
            nextMatchId: '1-r2-m2'
          },
          {
            id: '1-r1-m4',
            participant1: 'Морозов М.',
            participant2: 'Волков В.',
            score1: 0,
            score2: 1,
            nextMatchId: '1-r2-m2'
          },
          {
            id: '1-r1-m5',
            participant1: 'Алексеев А.',
            participant2: 'Лебедев Л.',
            score1: 1,
            score2: 0,
            nextMatchId: '1-r2-m3'
          },
          {
            id: '1-r1-m6',
            participant1: 'Семенов С.',
            participant2: 'Егоров Е.',
            score1: 0,
            score2: 1,
            nextMatchId: '1-r2-m3'
          },
          {
            id: '1-r1-m7',
            participant1: 'Павлов П.',
            participant2: 'Козлов К.',
            score1: 1,
            score2: 0,
            nextMatchId: '1-r2-m4'
          },
          {
            id: '1-r1-m8',
            participant1: 'Степанов С.',
            participant2: 'Николаев Н.',
            score1: 0,
            score2: 1,
            nextMatchId: '1-r2-m4'
          }
        ]
      },
      {
        id: '1-r2',
        name: '1/4 финала',
        matches: [
          {
            id: '1-r2-m1',
            participant1: 'Иванов И.',
            participant2: 'Смирнов С.',
            score1: 1,
            score2: 0,
            nextMatchId: '1-r3-m1'
          },
          {
            id: '1-r2-m2',
            participant1: 'Козлов К.',
            participant2: 'Волков В.',
            score1: 0,
            score2: 1,
            nextMatchId: '1-r3-m1'
          },
          {
            id: '1-r2-m3',
            participant1: 'Алексеев А.',
            participant2: 'Егоров Е.',
            score1: null,
            score2: null,
            nextMatchId: '1-r3-m2'
          },
          {
            id: '1-r2-m4',
            participant1: 'Павлов П.',
            participant2: 'Николаев Н.',
            score1: null,
            score2: null,
            nextMatchId: '1-r3-m2'
          }
        ]
      },
      {
        id: '1-r3',
        name: '1/2 финала',
        matches: [
          {
            id: '1-r3-m1',
            participant1: 'Иванов И.',
            participant2: 'Волков В.',
            score1: null,
            score2: null,
            nextMatchId: '1-r4-m1'
          },
          {
            id: '1-r3-m2',
            participant1: null,
            participant2: null,
            score1: null,
            score2: null,
            nextMatchId: '1-r4-m1'
          }
        ]
      },
      {
        id: '1-r4',
        name: 'Финал',
        matches: [
          {
            id: '1-r4-m1',
            participant1: null,
            participant2: null,
            score1: null,
            score2: null
          }
        ]
      }
    ],
    rules: 'Турнир проводится по олимпийской системе. Каждый матч играется до первой победы.',
    createdAt: '2024-05-01T10:00:00Z',
    updatedAt: '2024-05-10T15:30:00Z'
  },
  {
    id: '2',
    name: 'Турнир по теннису "Весна 2025"',
    bracketType: 'single-elimination',
    status: 'pending',
    startDate: '2025-05-10',
    maxParticipants: 8,
    participantsCount: 6,
    rounds: [
      {
        id: '2-r1',
        name: '1/4 финала',
        matches: [
          {
            id: '2-r1-m1',
            participant1: 'Федоров Ф.',
            participant2: 'Зайцев З.',
            score1: null,
            score2: null,
            nextMatchId: '2-r2-m1'
          },
          {
            id: '2-r1-m2',
            participant1: 'Макаров М.',
            participant2: 'Андреев А.',
            score1: null,
            score2: null,
            nextMatchId: '2-r2-m1'
          },
          {
            id: '2-r1-m3',
            participant1: 'Тарасов Т.',
            participant2: 'Соколов С.',
            score1: null,
            score2: null,
            nextMatchId: '2-r2-m2'
          },
          {
            id: '2-r1-m4',
            participant1: 'Кузнецов К.',
            participant2: null,
            score1: null,
            score2: null,
            nextMatchId: '2-r2-m2'
          }
        ]
      },
      {
        id: '2-r2',
        name: '1/2 финала',
        matches: [
          {
            id: '2-r2-m1',
            participant1: null,
            participant2: null,
            score1: null,
            score2: null,
            nextMatchId: '2-r3-m1'
          },
          {
            id: '2-r2-m2',
            participant1: null,
            participant2: null,
            score1: null,
            score2: null,
            nextMatchId: '2-r3-m1'
          }
        ]
      },
      {
        id: '2-r3',
        name: 'Финал',
        matches: [
          {
            id: '2-r3-m1',
            participant1: null,
            participant2: null,
            score1: null,
            score2: null
          }
        ]
      }
    ],
    rules: 'Турнир проводится по олимпийской системе. Каждый матч играется до двух побед.',
    createdAt: '2024-04-15T09:30:00Z',
    updatedAt: '2024-04-20T11:45:00Z'
  },
  {
    id: '3',
    name: 'Кубок по футболу 2025',
    bracketType: 'double-elimination',
    status: 'completed',
    startDate: '2025-07-05',
    endDate: '2025-07-20',
    maxParticipants: 16,
    participantsCount: 16,
    rounds: [
      {
        id: '3-r1',
        name: '1/8 финала',
        matches: [
          {
            id: '3-r1-m1',
            participant1: 'Команда А',
            participant2: 'Команда Б',
            score1: 2,
            score2: 1,
            nextMatchId: '3-r2-m1'
          },
          {
            id: '3-r1-m2',
            participant1: 'Команда В',
            participant2: 'Команда Г',
            score1: 3,
            score2: 0,
            nextMatchId: '3-r2-m1'
          },
          {
            id: '3-r1-m3',
            participant1: 'Команда Д',
            participant2: 'Команда Е',
            score1: 1,
            score2: 1,
            nextMatchId: '3-r2-m2'
          },
          {
            id: '3-r1-m4',
            participant1: 'Команда Ж',
            participant2: 'Команда З',
            score1: 0,
            score2: 2,
            nextMatchId: '3-r2-m2'
          },
          {
            id: '3-r1-m5',
            participant1: 'Команда И',
            participant2: 'Команда К',
            score1: 4,
            score2: 2,
            nextMatchId: '3-r2-m3'
          },
          {
            id: '3-r1-m6',
            participant1: 'Команда Л',
            participant2: 'Команда М',
            score1: 1,
            score2: 2,
            nextMatchId: '3-r2-m3'
          },
          {
            id: '3-r1-m7',
            participant1: 'Команда Н',
            participant2: 'Команда О',
            score1: 3,
            score2: 3,
            nextMatchId: '3-r2-m4'
          },
          {
            id: '3-r1-m8',
            participant1: 'Команда П',
            participant2: 'Команда Р',
            score1: 2,
            score2: 0,
            nextMatchId: '3-r2-m4'
          }
        ]
      },
      {
        id: '3-r2',
        name: '1/4 финала',
        matches: [
          {
            id: '3-r2-m1',
            participant1: 'Команда А',
            participant2: 'Команда В',
            score1: 1,
            score2: 2,
            nextMatchId: '3-r3-m1'
          },
          {
            id: '3-r2-m2',
            participant1: 'Команда Д',
            participant2: 'Команда З',
            score1: 0,
            score2: 1,
            nextMatchId: '3-r3-m1'
          },
          {
            id: '3-r2-m3',
            participant1: 'Команда И',
            participant2: 'Команда М',
            score1: 3,
            score2: 1,
            nextMatchId: '3-r3-m2'
          },
          {
            id: '3-r2-m4',
            participant1: 'Команда Н',
            participant2: 'Команда П',
            score1: 2,
            score2: 2,
            nextMatchId: '3-r3-m2'
          }
        ]
      },
      {
        id: '3-r3',
        name: '1/2 финала',
        matches: [
          {
            id: '3-r3-m1',
            participant1: 'Команда В',
            participant2: 'Команда З',
            score1: 2,
            score2: 0,
            nextMatchId: '3-r4-m1'
          },
          {
            id: '3-r3-m2',
            participant1: 'Команда И',
            participant2: 'Команда Н',
            score1: 1,
            score2: 2,
            nextMatchId: '3-r4-m1'
          }
        ]
      },
      {
        id: '3-r4',
        name: 'Финал',
        matches: [
          {
            id: '3-r4-m1',
            participant1: 'Команда В',
            participant2: 'Команда Н',
            score1: 3,
            score2: 1
          }
        ]
      }
    ],
    rules: 'Турнир проводится по олимпийской системе. Если в основное время матч заканчивается вничью, назначается серия пенальти.',
    createdAt: '2024-03-10T08:15:00Z',
    updatedAt: '2024-03-25T14:20:00Z'
  }
];

// Utility function to create empty bracket
const createEmptyBracket = (bracketType: string, maxParticipants: number) => {
  const rounds = [];
  let matchesInFirstRound = maxParticipants / 2;
  let roundCount = Math.log2(maxParticipants);
  
  for (let i = 0; i < roundCount; i++) {
    const matchesInRound = matchesInFirstRound / Math.pow(2, i);
    const matches = [];
    const roundId = `new-r${i + 1}`;
    
    for (let j = 0; j < matchesInRound; j++) {
      const matchId = `${roundId}-m${j + 1}`;
      const nextRoundIndex = i + 1;
      const nextMatchIndex = Math.floor(j / 2) + 1;
      const nextMatchId = nextRoundIndex < roundCount ? `new-r${nextRoundIndex + 1}-m${nextMatchIndex}` : undefined;
      
      matches.push({
        id: matchId,
        participant1: null,
        participant2: null,
        score1: null,
        score2: null,
        nextMatchId
      });
    }
    
    let roundName = '';
    if (i === roundCount - 1) roundName = 'Финал';
    else if (i === roundCount - 2) roundName = '1/2 финала';
    else if (i === roundCount - 3) roundName = '1/4 финала';
    else if (i === roundCount - 4) roundName = '1/8 финала';
    else if (i === roundCount - 5) roundName = '1/16 финала';
    else roundName = `Раунд ${i + 1}`;
    
    rounds.push({
      id: roundId,
      name: roundName,
      matches
    });
  }
  
  return rounds;
};

// MSW request handlers with proper headers and response formatting
export const handlers = [
  // GET /api/tournaments - get all tournaments
  http.get('/api/tournaments', async () => {
    await delay(500);
    return HttpResponse.json(tournaments, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }),
  
  // GET /api/tournaments/:id - get tournament by ID
  http.get('/api/tournaments/:id', async ({ params }) => {
    await delay(300);
    const { id } = params;
    const tournament = tournaments.find((t) => t.id === id);
    
    if (!tournament) {
      return new HttpResponse(null, { 
        status: 404,
        headers: {
          'Content-Type': 'application/json'
        }
      });
    }
    
    return HttpResponse.json(tournament, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }),
  
  // POST /api/tournaments - create new tournament
  http.post('/api/tournaments', async ({ request }) => {
    await delay(600);
    const data: TournamentFormData = await request.json();
    
    const newTournament: Tournament = {
      id: uuidv4(),
      name: data.name,
      bracketType: data.bracketType,
      status: 'pending',
      startDate: data.startDate,
      maxParticipants: data.maxParticipants,
      participantsCount: 0,
      rounds: createEmptyBracket(data.bracketType, data.maxParticipants),
      rules: data.rules || '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    tournaments.push(newTournament);
    return HttpResponse.json(newTournament, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }),
  
  // PUT /api/tournaments/:id - update tournament
  http.put('/api/tournaments/:id', async ({ params, request }) => {
    await delay(400);
    const { id } = params;
    const data = await request.json();
    
    const tournamentIndex = tournaments.findIndex((t) => t.id === id);
    
    if (tournamentIndex === -1) {
      return new HttpResponse(null, { 
        status: 404,
        headers: {
          'Content-Type': 'application/json'
        }
      });
    }
    
    const updatedTournament = {
      ...tournaments[tournamentIndex],
      ...data,
      updatedAt: new Date().toISOString()
    };
    
    tournaments[tournamentIndex] = updatedTournament;
    return HttpResponse.json(updatedTournament, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }),
  
  // DELETE /api/tournaments/:id - delete tournament
  http.delete('/api/tournaments/:id', async ({ params }) => {
    await delay(400);
    const { id } = params;
    
    const tournamentIndex = tournaments.findIndex((t) => t.id === id);
    
    if (tournamentIndex === -1) {
      return new HttpResponse(null, { 
        status: 404,
        headers: {
          'Content-Type': 'application/json'
        }
      });
    }
    
    tournaments = tournaments.filter((t) => t.id !== id);
    return new HttpResponse(null, { 
      status: 204,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  })
];
</file>

<file path="src/pages/AboutPage.tsx">
import React from 'react';
import { Github } from 'lucide-react';
import Button from '../components/Button';

const AboutPage: React.FC = () => {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">О проекте</h1>
      
      <div className="card mb-8">
        <h2 className="text-xl font-semibold mb-4">Цели проекта</h2>
        <p className="mb-4">
          Наш проект "ТурнирПро" предназначен для упрощения организации и проведения турниров различных форматов. 
          От спортивных соревнований до киберспортивных турниров — наша платформа поможет вам:
        </p>
        
        <ul className="list-disc list-inside space-y-2 mb-4 pl-4">
          <li>Создавать турниры с различными типами сеток</li>
          <li>Отслеживать результаты матчей в реальном времени</li>
          <li>Автоматизировать процесс распределения участников</li>
          <li>Экспортировать данные для использования в других приложениях</li>
        </ul>
        
        <p>
          Это open-source проект, и мы приветствуем вклад сообщества в его развитие.
        </p>
      </div>
      
      <div className="card mb-8">
        <h2 className="text-xl font-semibold mb-4">Технологический стек</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="font-medium text-gray-700 mb-2">Фронтенд:</h3>
            <ul className="list-disc list-inside space-y-1 pl-4">
              <li>React + TypeScript</li>
              <li>React Router v6</li>
              <li>Tailwind CSS</li>
              <li>Lucide Icons</li>
            </ul>
          </div>
          
          <div>
            <h3 className="font-medium text-gray-700 mb-2">API и бэкенд:</h3>
            <ul className="list-disc list-inside space-y-1 pl-4">
              <li>Mock Service Worker (MSW)</li>
              <li>JSON Server</li>
              <li>RESTful API</li>
              <li>Node.js + Express (планируется)</li>
            </ul>
          </div>
        </div>
        
        <div className="mt-6">
          <h3 className="font-medium text-gray-700 mb-2">Инструменты разработки:</h3>
          <ul className="list-disc list-inside space-y-1 pl-4">
            <li>Vite</li>
            <li>ESLint</li>
            <li>Prettier</li>
            <li>Jest + React Testing Library</li>
            <li>Cypress</li>
          </ul>
        </div>
      </div>
      
      <div className="card">
        <h2 className="text-xl font-semibold mb-4">Ресурсы и документация</h2>
        
        <div className="space-y-4">
          <div className="flex items-start space-x-4">
            <div className="bg-gray-100 p-2 rounded-full">
              <Github className="h-6 w-6 text-gray-600" />
            </div>
            <div>
              <h3 className="font-medium text-gray-700">Репозиторий проекта</h3>
              <p className="text-gray-600 text-sm mb-2">
                Посетите наш GitHub репозиторий, чтобы посмотреть исходный код и внести свой вклад.
              </p>
              <Button variant="secondary" size="sm">
                Перейти на GitHub
              </Button>
            </div>
          </div>
          
          <div className="flex items-start space-x-4">
            <div className="bg-gray-100 p-2 rounded-full">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
            </div>
            <div>
              <h3 className="font-medium text-gray-700">Документация API</h3>
              <p className="text-gray-600 text-sm mb-2">
                Подробная документация по всем эндпоинтам API и примеры использования.
              </p>
              <Button variant="secondary" size="sm">
                Документация API
              </Button>
            </div>
          </div>
          
          <div className="flex items-start space-x-4">
            <div className="bg-gray-100 p-2 rounded-full">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div>
              <h3 className="font-medium text-gray-700">Руководство пользователя</h3>
              <p className="text-gray-600 text-sm mb-2">
                Инструкции по использованию платформы и лучшие практики организации турниров.
              </p>
              <Button variant="secondary" size="sm">
                Руководство пользователя
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AboutPage;
</file>

<file path="src/pages/BracketPage.tsx">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { ArrowLeft, Edit, Settings } from 'lucide-react';
import Button from '../components/Button';
import BracketGrid from '../components/BracketGrid';
import { Tournament } from '../types/tournament';
import { getTournamentById, updateMatchScore } from '../api/tournaments';
import { toast } from 'react-toastify';

const BracketPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const fetchTournament = async () => {
      if (!id) return;
      
      try {
        const data = await getTournamentById(id);
        setTournament(data);
      } catch (error) {
        console.error('Error fetching tournament:', error);
        toast.error('Не удалось загрузить данные турнира');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchTournament();
  }, [id]);
  
  const handleScoreUpdate = async (matchId: string, score1: number, score2: number) => {
    if (!id) return;
    
    try {
      await updateMatchScore(id, matchId, score1, score2);
      
      // Обновляем локальное состояние
      setTournament(prev => {
        if (!prev) return null;
        
        const updatedRounds = prev.rounds.map(round => {
          const updatedMatches = round.matches.map(match => {
            if (match.id === matchId) {
              return { ...match, score1, score2 };
            }
            return match;
          });
          
          return { ...round, matches: updatedMatches };
        });
        
        return { ...prev, rounds: updatedRounds };
      });
      
      toast.success('Счет матча обновлен');
    } catch (error) {
      console.error('Error updating match score:', error);
      toast.error('Не удалось обновить счет матча');
    }
  };
  
  if (isLoading) {
    return (
      <div className="flex justify-center p-12">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (!tournament) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Турнир не найден</h2>
        <p className="text-gray-600 mb-6">Турнир с указанным ID не существует или был удален.</p>
        <Button 
          variant="primary"
          onClick={() => navigate('/')}
        >
          Вернуться на главную
        </Button>
      </div>
    );
  }
  
  const getTournamentStatusText = (status: string) => {
    switch (status) {
      case 'active': return 'Активный';
      case 'pending': return 'Ожидание';
      case 'completed': return 'Завершен';
      case 'cancelled': return 'Отменен';
      default: return status;
    }
  };
  
  return (
    <div>
      <div className="mb-6">
        <Button 
          variant="ghost" 
          onClick={() => navigate('/')}
          leftIcon={<ArrowLeft size={16} />}
        >
          Назад к списку
        </Button>
      </div>
      
      <div className="bg-white p-6 rounded-lg shadow-md mb-8">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
          <div>
            <h1 className="text-2xl font-bold">{tournament.name}</h1>
            <div className="flex items-center mt-2 space-x-2">
              <span className={`tournament-status-${tournament.status}`}>
                {getTournamentStatusText(tournament.status)}
              </span>
              <span className="text-sm text-gray-600">
                {tournament.participantsCount} из {tournament.maxParticipants} участников
              </span>
            </div>
          </div>
          
          <div className="flex space-x-3 mt-4 md:mt-0">
            <Button 
              variant="secondary"
              onClick={() => navigate(`/tournaments/${id}/edit`)}
              leftIcon={<Edit size={16} />}
            >
              Редактировать
            </Button>
            <Button 
              variant="secondary"
              onClick={() => navigate(`/tournaments/${id}/settings`)}
              leftIcon={<Settings size={16} />}
            >
              Настройки
            </Button>
          </div>
        </div>
        
        {tournament.rules && (
          <div className="mt-4 p-4 bg-gray-50 rounded-md">
            <h3 className="text-sm font-medium text-gray-700 mb-2">Правила турнира:</h3>
            <p className="text-sm text-gray-600 whitespace-pre-line">{tournament.rules}</p>
          </div>
        )}
      </div>
      
      <BracketGrid 
        tournament={tournament} 
        onScoreUpdate={handleScoreUpdate}
      />
    </div>
  );
};

export default BracketPage;
</file>

<file path="src/pages/DashboardPage.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Plus, Search, Filter } from 'lucide-react';
import Button from '../components/Button';
import TournamentCard from '../components/TournamentCard';
import { Tournament } from '../types/tournament';
import { getAllTournaments, deleteTournament } from '../api/tournaments';
import { toast } from 'react-toastify';

const DashboardPage: React.FC = () => {
  const navigate = useNavigate();
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [filteredTournaments, setFilteredTournaments] = useState<Tournament[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  
  useEffect(() => {
    const fetchTournaments = async () => {
      try {
        const data = await getAllTournaments();
        setTournaments(data);
        setFilteredTournaments(data);
      } catch (error) {
        console.error('Error fetching tournaments:', error);
        toast.error('Не удалось загрузить список турниров');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchTournaments();
  }, []);
  
  useEffect(() => {
    let result = tournaments;
    
    // Применяем фильтр по поиску
    if (searchTerm) {
      result = result.filter(tournament => 
        tournament.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Применяем фильтр по статусу
    if (statusFilter !== 'all') {
      result = result.filter(tournament => tournament.status === statusFilter);
    }
    
    setFilteredTournaments(result);
  }, [searchTerm, statusFilter, tournaments]);
  
  const handleDelete = async (id: string) => {
    if (window.confirm('Вы уверены, что хотите удалить этот турнир?')) {
      try {
        await deleteTournament(id);
        setTournaments(prev => prev.filter(tournament => tournament.id !== id));
        toast.success('Турнир успешно удален');
      } catch (error) {
        console.error('Error deleting tournament:', error);
        toast.error('Не удалось удалить турнир');
      }
    }
  };
  
  return (
    <div>
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-8">
        <h1 className="text-3xl font-bold mb-4 md:mb-0">Турниры</h1>
        <Button 
          variant="primary"
          onClick={() => navigate('/tournaments/new')}
          leftIcon={<Plus size={16} />}
        >
          Создать турнир
        </Button>
      </div>
      
      <div className="mb-6 bg-white p-4 rounded-lg shadow-sm">
        <div className="flex flex-col md:flex-row gap-4">
          <div className="relative flex-grow">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              <Search size={18} className="text-gray-400" />
            </div>
            <input
              type="text"
              placeholder="Поиск турниров..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10 w-full form-input"
            />
          </div>
          
          <div className="relative w-full md:w-64">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
              <Filter size={18} className="text-gray-400" />
            </div>
            <select
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              className="pl-10 w-full form-input appearance-none"
            >
              <option value="all">Все статусы</option>
              <option value="pending">Ожидание</option>
              <option value="active">Активные</option>
              <option value="completed">Завершенные</option>
              <option value="cancelled">Отмененные</option>
            </select>
          </div>
        </div>
      </div>
      
      {isLoading ? (
        <div className="flex justify-center p-12">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
        </div>
      ) : filteredTournaments.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {filteredTournaments.map(tournament => (
            <TournamentCard 
              key={tournament.id} 
              tournament={tournament} 
              onDelete={handleDelete}
            />
          ))}
        </div>
      ) : (
        <div className="text-center py-12 bg-white rounded-lg shadow-sm">
          <h3 className="text-xl font-medium text-gray-700 mb-2">
            {tournaments.length === 0 ? 'Нет доступных турниров' : 'Турниры не найдены'}
          </h3>
          <p className="text-gray-500 mb-6">
            {tournaments.length === 0 
              ? 'Создайте ваш первый турнир, чтобы начать работу.' 
              : 'Попробуйте изменить параметры поиска или фильтрации.'}
          </p>
          {tournaments.length === 0 && (
            <Button 
              variant="primary"
              onClick={() => navigate('/tournaments/new')}
              leftIcon={<Plus size={16} />}
            >
              Создать турнир
            </Button>
          )}
        </div>
      )}
    </div>
  );
};

export default DashboardPage;
</file>

<file path="src/pages/NotFoundPage.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { Home } from 'lucide-react';
import Button from '../components/Button';

const NotFoundPage: React.FC = () => {
  const navigate = useNavigate();
  
  return (
    <div className="flex flex-col items-center justify-center py-16">
      <div className="text-center">
        <h1 className="text-9xl font-bold text-gray-200">404</h1>
        <h2 className="text-3xl font-semibold mb-4">Страница не найдена</h2>
        <p className="text-gray-600 mb-8 max-w-md mx-auto">
          Извините, запрашиваемая страница не существует или была перемещена.
        </p>
        <Button 
          variant="primary"
          onClick={() => navigate('/')}
          leftIcon={<Home size={18} />}
        >
          На главную
        </Button>
      </div>
    </div>
  );
};

export default NotFoundPage;
</file>

<file path="src/pages/TournamentEditPage.tsx">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { ArrowLeft } from 'lucide-react';
import Button from '../components/Button';
import TournamentForm from '../components/TournamentForm';
import { Tournament } from '../types/tournament';
import { getTournamentById, updateTournament } from '../api/tournaments';
import { toast } from 'react-toastify';

const TournamentEditPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const fetchTournament = async () => {
      if (!id) return;
      
      try {
        const data = await getTournamentById(id);
        setTournament(data);
      } catch (error) {
        console.error('Error fetching tournament:', error);
        toast.error('Не удалось загрузить данные турнира');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchTournament();
  }, [id]);
  
  const handleSubmit = async (data: Partial<Tournament>) => {
    if (!id) return;
    
    try {
      await updateTournament(id, data);
      toast.success('Турнир успешно обновлен');
      navigate(`/tournaments/${id}`);
    } catch (error) {
      console.error('Error updating tournament:', error);
      toast.error('Не удалось обновить турнир');
      throw error;
    }
  };
  
  if (isLoading) {
    return (
      <div className="flex justify-center p-12">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (!tournament) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Турнир не найден</h2>
        <p className="text-gray-600 mb-6">Турнир с указанным ID не существует или был удален.</p>
        <Button 
          variant="primary"
          onClick={() => navigate('/')}
        >
          Вернуться на главную
        </Button>
      </div>
    );
  }
  
  return (
    <div>
      <div className="mb-6">
        <Button 
          variant="ghost" 
          onClick={() => navigate(`/tournaments/${id}`)}
          leftIcon={<ArrowLeft size={16} />}
        >
          Назад к турниру
        </Button>
      </div>
      
      <TournamentForm 
        initialData={tournament} 
        onSubmit={handleSubmit} 
        isEditing={true}
      />
    </div>
  );
};

export default TournamentEditPage;
</file>

<file path="src/pages/TournamentFormPage.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { ArrowLeft } from 'lucide-react';
import Button from '../components/Button';
import TournamentForm from '../components/TournamentForm';
import { TournamentFormData } from '../types/tournament';
import { createTournament } from '../api/tournaments';
import { toast } from 'react-toastify';

const TournamentFormPage: React.FC = () => {
  const navigate = useNavigate();
  
  const handleSubmit = async (data: TournamentFormData) => {
    try {
      await createTournament(data);
      toast.success('Турнир успешно создан');
      navigate('/');
    } catch (error) {
      console.error('Error creating tournament:', error);
      toast.error('Не удалось создать турнир');
      throw error;
    }
  };
  
  return (
    <div>
      <div className="mb-6">
        <Button 
          variant="ghost" 
          onClick={() => navigate('/')}
          leftIcon={<ArrowLeft size={16} />}
        >
          Назад к списку
        </Button>
      </div>
      
      <TournamentForm onSubmit={handleSubmit} />
    </div>
  );
};

export default TournamentFormPage;
</file>

<file path="src/pages/TournamentSettingsPage.tsx">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { ArrowLeft, Bell, Clock, DownloadCloud } from 'lucide-react';
import Button from '../components/Button';
import ExportOptions from '../components/ExportOptions';
import { Tournament } from '../types/tournament';
import { getTournamentById, updateTournament } from '../api/tournaments';
import { toast } from 'react-toastify';

const TournamentSettingsPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [settings, setSettings] = useState({
    enableTimer: false,
    enableNotifications: false,
    autoAdvance: false
  });
  
  useEffect(() => {
    const fetchTournament = async () => {
      if (!id) return;
      
      try {
        const data = await getTournamentById(id);
        setTournament(data);
      } catch (error) {
        console.error('Error fetching tournament:', error);
        toast.error('Не удалось загрузить данные турнира');
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchTournament();
  }, [id]);
  
  const handleToggleSetting = (setting: keyof typeof settings) => {
    setSettings(prev => ({
      ...prev,
      [setting]: !prev[setting]
    }));
    
    // Здесь можно было бы сохранять настройки на сервере
    toast.success(`Настройка "${setting}" ${settings[setting] ? 'отключена' : 'включена'}`);
  };
  
  const handleStatusChange = async (status: string) => {
    if (!id || !tournament) return;
    
    try {
      await updateTournament(id, { status: status as Tournament['status'] });
      setTournament(prev => prev ? { ...prev, status: status as Tournament['status'] } : null);
      toast.success('Статус турнира обновлен');
    } catch (error) {
      console.error('Error updating tournament status:', error);
      toast.error('Не удалось обновить статус турнира');
    }
  };
  
  if (isLoading) {
    return (
      <div className="flex justify-center p-12">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (!tournament) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Турнир не найден</h2>
        <p className="text-gray-600 mb-6">Турнир с указанным ID не существует или был удален.</p>
        <Button 
          variant="primary"
          onClick={() => navigate('/')}
        >
          Вернуться на главную
        </Button>
      </div>
    );
  }
  
  return (
    <div>
      <div className="mb-6">
        <Button 
          variant="ghost" 
          onClick={() => navigate(`/tournaments/${id}`)}
          leftIcon={<ArrowLeft size={16} />}
        >
          Назад к турниру
        </Button>
      </div>
      
      <h1 className="text-2xl font-bold mb-6">Настройки турнира</h1>
      
      <div className="space-y-6">
        <ExportOptions tournament={tournament} />
        
        <div className="card mb-6">
          <h3 className="text-lg font-semibold mb-4">Статус турнира</h3>
          
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
            <Button 
              variant={tournament.status === 'pending' ? 'primary' : 'secondary'}
              onClick={() => handleStatusChange('pending')}
            >
              Ожидание
            </Button>
            <Button 
              variant={tournament.status === 'active' ? 'primary' : 'secondary'}
              onClick={() => handleStatusChange('active')}
            >
              Активный
            </Button>
            <Button 
              variant={tournament.status === 'completed' ? 'primary' : 'secondary'}
              onClick={() => handleStatusChange('completed')}
            >
              Завершен
            </Button>
            <Button 
              variant={tournament.status === 'cancelled' ? 'primary' : 'secondary'}
              onClick={() => handleStatusChange('cancelled')}
            >
              Отменен
            </Button>
          </div>
        </div>
        
        <div className="card">
          <h3 className="text-lg font-semibold mb-4">Дополнительные настройки</h3>
          
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <Clock className="h-5 w-5 text-gray-500 mr-3" />
                <span>Включить таймер матчей</span>
              </div>
              <label className="inline-flex items-center cursor-pointer">
                <input 
                  type="checkbox" 
                  className="sr-only peer"
                  checked={settings.enableTimer}
                  onChange={() => handleToggleSetting('enableTimer')}
                />
                <div className="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
            
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <Bell className="h-5 w-5 text-gray-500 mr-3" />
                <span>Включить уведомления</span>
              </div>
              <label className="inline-flex items-center cursor-pointer">
                <input 
                  type="checkbox" 
                  className="sr-only peer"
                  checked={settings.enableNotifications}
                  onChange={() => handleToggleSetting('enableNotifications')}
                />
                <div className="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
            
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <DownloadCloud className="h-5 w-5 text-gray-500 mr-3" />
                <span>Автоматическое продвижение победителей</span>
              </div>
              <label className="inline-flex items-center cursor-pointer">
                <input 
                  type="checkbox" 
                  className="sr-only peer"
                  checked={settings.autoAdvance}
                  onChange={() => handleToggleSetting('autoAdvance')}
                />
                <div className="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TournamentSettingsPage;
</file>

<file path="src/types/tournament.ts">
export interface Match {
  id: string;
  participant1: string | null;
  participant2: string | null;
  score1: number | null;
  score2: number | null;
  winnerId?: string | null;
  nextMatchId?: string | null;
}

export interface Round {
  id: string;
  name: string;
  matches: Match[];
}

export interface Tournament {
  id: string;
  name: string;
  bracketType: string;
  status: 'pending' | 'active' | 'completed' | 'cancelled';
  startDate: string;
  endDate?: string;
  maxParticipants: number;
  participantsCount: number;
  participants?: string[];
  rounds: Round[];
  rules?: string;
  createdAt: string;
  updatedAt: string;
}

export interface TournamentFormData {
  name: string;
  bracketType: string;
  maxParticipants: number;
  startDate: string;
  rules?: string;
}
</file>

<file path="src/utils/dateUtils.ts">
import { format, parseISO } from 'date-fns';
import { ru } from 'date-fns/locale';

export const formatDate = (dateString: string): string => {
  try {
    const date = parseISO(dateString);
    return format(date, 'dd MMMM yyyy', { locale: ru });
  } catch (error) {
    console.error('Error formatting date:', error);
    return dateString;
  }
};

export const formatDateTime = (dateString: string): string => {
  try {
    const date = parseISO(dateString);
    return format(date, 'dd MMMM yyyy, HH:mm', { locale: ru });
  } catch (error) {
    console.error('Error formatting date time:', error);
    return dateString;
  }
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    exclude: ['lucide-react']
  },
  server: {
    watch: {
      usePolling: true
    }
  },
  publicDir: 'public'
});
</file>

</files>
